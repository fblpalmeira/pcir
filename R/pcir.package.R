
#' pcir Package Functions and Setup
#'
#' This file contains the basic setup and utility functions for the 'pcir' package.
#' The pcir package is designed for calculating, comparing, and visualizing the
#' Potential for Conflict Index (PCI).
#'
#' @section Functions:
#' - `counting()`: Summarize data by calculating counts, percentages, means, and standard deviations.
#' - `pci()`: Compute the Potential for Conflict Index (PCI) from summary data.
#' - `bubble()`: Create a bubble plot to visualize PCI results.
#'
#' @name pcir-package
#' @keywords internal
#' @import Hmisc
#' @import dplyr
#' @import ggplot2
#' @import magrittr
#' @import tidyr
#' @import devtools
#' @import roxygen2
#' @import rprojroot
#' @export counting
#' @export pci
#' @export bubble
NULL

#' Counting Function
#'
#' @description Create a count table with percentages, mean, and standard deviation.
#' This function takes a data frame, computes summary statistics like counts, percentages,
#' means, and standard deviations for each unique value in the selected columns.
#'
#' @param df1 A data frame containing the data to be processed.
#' @param cols A vector of column names to be included in the calculation.
#' @return A data frame with computed statistics, including counts, percentages, means, and standard deviations.
#' df1 <- data.frame(A = c(-1, -1, -1, 0, -1), B = c(-1, 1, 0, -1, 1),
#'                   C = c(1, 1, 1, 0, -1), D = c(0, -1, 1, 1, 1), E = c(1, 1, 0, -1, -1))
#' counting(df1, cols = c('A', 'B', 'C', 'D', 'E'))
#' @export
counting <- function(df1, cols) {
  df1 %>%
    dplyr::select(all_of(cols)) %>%
    tidyr::pivot_longer(everything()) %>%
    dplyr::group_by(name, value) %>%
    dplyr::summarise(Count = n(), .groups = 'drop_last') %>%
    dplyr::group_by(name) %>%
    dplyr::mutate(
      Percentage = round(100 * (Count / sum(Count)), 2),
      Mean = round(weighted.mean(value, Count), 2),
      SD = round(sqrt(Hmisc::wtd.var(value, Count)), 2),
      Total = sum(Count)
    ) %>%
    dplyr::ungroup() %>%
    tidyr::pivot_wider(
      names_from = 'value',
      names_sep = ' ',
      values_from = c('Count', 'Percentage'),
      names_vary = 'slowest'
    )
}

#' PCI Function
#'
#' @description Calculate the Potential for Conflict Index (PCI).
#' This function computes the PCI by comparing the counts of positive and negative
#' values within a dataset. The PCI value is normalized by the total responses.
#'
#' @param df2 A data frame generated by the `counting` function, containing the summarized data.
#' @param negative_val The value representing negative responses. Default is '-1'.
#' @param positive_val The value representing positive responses. Default is '1'.
#' @param scale_type The scale type used: 'bipolar' or 'unipolar'. Default is 'bipolar'.
#' @return A data frame with the calculated PCI values for each group.
#' @examples
#' df2 <- counting(df1)
#' pci(df2)
#' @export
pci <- function(df2, negative_val = -1, positive_val = 1, scale_type = c('bipolar', 'unipolar')) {
  scale_type <- match.arg(scale_type)

  neg_col <- paste0('Count ', negative_val)
  pos_col <- paste0('Count ', positive_val)

  if (!(neg_col %in% names(df2)) || !(pos_col %in% names(df2))) {
    stop('One or both specified Count columns not found in the data.')
  }

  df2 %>%
    mutate(
      nu = .data[[neg_col]],
      na = .data[[pos_col]],
      xt = nu + na,
      z = Total,
      PCI = (1 - (na / xt - nu / xt)) * xt / z
    ) %>%
    mutate(across(where(is.numeric), function(x) round(x, 2)))
}

#' Bubble Plot Function
#'
#' @description Create a bubble plot to visualize PCI results.
#' This function generates a bubble plot where each bubble represents a group.
#' The size of the bubble corresponds to the PCI value, and the y-axis shows the mean
#' action acceptability for each group.
#'
#' @param df3 A data frame generated by the `pci` function, containing the PCI values and other statistics.
#' @param scale_type The scale type used for the plot: 'bipolar' or 'unipolar'. Default is 'bipolar'.
#' @param ylim_range For 'bipolar' scale, the range of the y-axis. Must be an integer between 1 and 4.
#' @param unipolar_ylim A numeric vector of length 2 specifying the y-axis limits for 'unipolar' scale.
#' @param xlab The label for the x-axis. Default is an empty string.
#' @param ylab The label for the y-axis. Default is 'Action acceptability'.
#' @param title Optional title for the plot. Default is NULL.
#' @param bubble_color The fill color of the bubbles. Default is 'gray80'.
#' @param bubble_stroke The border color of the bubbles. Default is 'black'.
#' @return A ggplot2 object representing the bubble plot.
#' @examples
#' df3 <- pci(df2)
#' bubble(df3)
#' @export
bubble <- function(df3,
                   scale_type = c('bipolar', 'unipolar'),
                   ylim_range = 4,
                   unipolar_ylim = c(1, 9),
                   xlab = '',
                   ylab = 'Action acceptability',
                   title = NULL,
                   bubble_color = 'gray80',
                   bubble_stroke = 'black') {
  scale_type <- match.arg(scale_type)

  if (scale_type == 'unipolar') {
    if (!is.numeric(unipolar_ylim) || length(unipolar_ylim) != 2) {
      stop('For unipolar scale, unipolar_ylim must be a numeric vector of length 2.')
    }
    y_limits <- unipolar_ylim
  } else {
    if (!ylim_range %in% 1:4) {
      stop('For bipolar scale, ylim_range must be 1, 2, 3, or 4.')
    }
    y_limits <- c(-ylim_range, ylim_range)
  }

  p <- ggplot(df3, aes(x = name, y = Mean, size = PCI)) +
    geom_hline(yintercept = 0, colour = 'black') +
    geom_point(shape = 21, fill = bubble_color, color = bubble_stroke, show.legend = TRUE) +
    geom_text(aes(label = round(PCI, 2)),
              nudge_y = 0.35, nudge_x = 0.1, size = 5) +
    ylab(ylab) + xlab(xlab) +
    ylim(y_limits) +
    scale_size_area(max_size = 14) +
    theme_minimal() +
    theme(panel.grid.major.y = element_blank(),
          panel.grid.minor.y = element_blank(),
          panel.grid.major.x = element_blank(),
          panel.grid.minor.x = element_blank(),
          axis.title.x = element_text(size = 16),
          axis.title.y = element_text(size = 16),
          axis.text.x = element_text(size = 14, angle = 45, vjust = 1, hjust = 1),
          axis.text.y = element_text(size = 14),
          axis.line.x = element_line(colour = 'white'),
          axis.line.y = element_line(colour = 'black'),
          axis.ticks = element_line(colour = 'black'),
          legend.key.size = unit(1, 'cm'),
          legend.key.height = unit(1, 'cm'),
          legend.key.width = unit(1, 'cm'),
          legend.title = element_text(size = 16),
          legend.text = element_text(size = 14))

  if (!is.null(title)) {
    p <- p + ggtitle(title) +
      theme(plot.title = element_text(size = 18, face = 'bold', hjust = 0.5))
  }

  return(p)
}

